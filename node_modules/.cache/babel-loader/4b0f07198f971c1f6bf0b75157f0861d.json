{"ast":null,"code":"'use strict';\n\nvar React = require('react');\nvar reactRouterDom = require('react-router-dom');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n\n/**\n * The default scroll function used by all components of this library\n */\nvar DEFAULT_SCROLL_FUNC = function DEFAULT_SCROLL_FUNC(ref, behavior, position) {\n  var _a;\n  (_a = ref.current) === null || _a === void 0 ? void 0 : _a.scrollIntoView({\n    behavior: behavior,\n    block: position,\n    inline: position\n  });\n};\n\n/**\n * The default scroll behavior used by all components of this library\n */\nvar DEFAULT_SCROLL_BEHAVIOR = \"smooth\";\n/**\n * The default scroll position used by all components of this library\n */\nvar DEFAULT_SCROLL_POSITION = \"center\";\n\n// React Imports\nfunction useHashScroll(hash, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _a = reactRouterDom.useLocation(),\n    urlHash = _a.hash,\n    pathname = _a.pathname;\n  var ref = React.useRef(null);\n  var _b = options.behavior,\n    behavior = _b === void 0 ? DEFAULT_SCROLL_BEHAVIOR : _b,\n    _c = options.position,\n    position = _c === void 0 ? DEFAULT_SCROLL_POSITION : _c,\n    _d = options.scrollFunc,\n    scrollFunc = _d === void 0 ? DEFAULT_SCROLL_FUNC : _d;\n  var requiredPathname = options.requiredPathname;\n  if (hash.charAt(0) !== \"#\") {\n    hash = \"#\" + hash;\n  }\n  if (typeof requiredPathname === \"string\") {\n    requiredPathname = [requiredPathname];\n  }\n  React.useEffect(function () {\n    if (urlHash === hash && (requiredPathname === undefined || requiredPathname.includes(pathname))) {\n      if (ref.current) {\n        scrollFunc(ref, behavior, position);\n      }\n    }\n  }, [urlHash, ref, hash, requiredPathname, pathname, scrollFunc, behavior, position]);\n  return ref;\n}\n\n//React Imports\n/**\n * Scrolls to child element when the specified hash is present in the url\n *\n * Note: **ONLY** 1 child element allowed\n */\nvar HashScroll = function HashScroll(_a) {\n  var hash = _a.hash,\n    children = _a.children,\n    behavior = _a.behavior,\n    position = _a.position,\n    requiredPathname = _a.requiredPathname,\n    scrollFunc = _a.scrollFunc;\n  var childRef = useHashScroll(hash, {\n    behavior: behavior,\n    position: position,\n    requiredPathname: requiredPathname,\n    scrollFunc: scrollFunc\n  });\n  return React.cloneElement(children, {\n    ref: childRef\n  });\n};\n\n// React Imports\nvar createHashFunc = function createHashFunc(ref, options, defaultOptions, pathname) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  var behavior = defaultOptions.behavior,\n    position = defaultOptions.position,\n    requiredPathname = defaultOptions.requiredPathname,\n    scrollFunc = defaultOptions.scrollFunc;\n  var req = (_a = options.requiredPathname) !== null && _a !== void 0 ? _a : requiredPathname;\n  if (typeof req === \"string\") req = [req];\n  var b = (_c = (_b = options.behavior) !== null && _b !== void 0 ? _b : behavior) !== null && _c !== void 0 ? _c : DEFAULT_SCROLL_BEHAVIOR;\n  var p = (_e = (_d = options.position) !== null && _d !== void 0 ? _d : position) !== null && _e !== void 0 ? _e : DEFAULT_SCROLL_POSITION;\n  var s = (_g = (_f = options.scrollFunc) !== null && _f !== void 0 ? _f : scrollFunc) !== null && _g !== void 0 ? _g : DEFAULT_SCROLL_FUNC;\n  return function () {\n    if ((req === undefined || req.includes(pathname)) && ref.current) {\n      s(ref, b, p);\n    }\n  };\n};\n/**\n * Component that pairs hashes with refs and scrolls to a corresponding ref when one of the hashes is present in the url\n */\nvar MultiHash = function MultiHash(_a) {\n  var hashes = _a.hashes,\n    children = _a.children,\n    behavior = _a.behavior,\n    position = _a.position,\n    requiredPathname = _a.requiredPathname,\n    scrollFunc = _a.scrollFunc;\n  var _b = reactRouterDom.useLocation(),\n    urlHash = _b.hash,\n    pathname = _b.pathname;\n  var defaultOptions = React.useMemo(function () {\n    return {\n      behavior: behavior,\n      position: position,\n      requiredPathname: requiredPathname,\n      scrollFunc: scrollFunc\n    };\n  }, [behavior, position, requiredPathname, scrollFunc]);\n  var hashFuncs = React.useMemo(function () {\n    return {};\n  }, [hashes, defaultOptions, pathname]);\n  React.useMemo(function () {\n    for (var hash in hashes) {\n      var value = hashes[hash];\n      if (hash.charAt(0) !== \"#\") {\n        hash = \"#\" + hash;\n      }\n      if (Array.isArray(value)) hashFuncs[hash] = createHashFunc(value[0], value[1], defaultOptions, pathname);else hashFuncs[hash] = createHashFunc(value, {}, defaultOptions, pathname);\n    }\n  }, [hashes, defaultOptions, pathname]);\n  React.useEffect(function () {\n    var scroll = hashFuncs[urlHash];\n    if (typeof scroll === \"function\") {\n      scroll();\n    }\n  }, [urlHash, hashFuncs]);\n  return React__default['default'].createElement(React__default['default'].Fragment, null, children);\n};\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return _assign.apply(this, arguments);\n};\nfunction warning(condition, message) {\n  {\n    if (condition) {\n      return;\n    }\n    var text = \"Warning: \" + message;\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\nvar CHILDREN_HASH_UNEQUAL_LENGTHS = \"The number of hashes and children should be the same so that each child corresponds to a hash (ChildrenHash) - React Hash Scroll\";\nvar createChild = function createChild(child, defaultOptions, hash) {\n  if (!hash) return child;\n  if (typeof hash === \"string\") return React__default['default'].createElement(HashScroll, _assign({}, defaultOptions, {\n    hash: hash\n  }), child);\n  return React__default['default'].createElement(HashScroll, _assign({}, defaultOptions, hash), child);\n};\n/**\n * Scrolls to corresponding child element when one of the hashes is present in the url\n */\nvar ChildrenHash = function ChildrenHash(_a) {\n  var hashes = _a.hashes,\n    children = _a.children,\n    behavior = _a.behavior,\n    position = _a.position,\n    requiredPathname = _a.requiredPathname,\n    scrollFunc = _a.scrollFunc;\n  warning(hashes.length === children.length, CHILDREN_HASH_UNEQUAL_LENGTHS);\n  return React__default['default'].createElement(React__default['default'].Fragment, null, children.map(function (child, i) {\n    return React__default['default'].createElement(React.Fragment, {\n      key: i\n    }, createChild(child, {\n      behavior: behavior,\n      position: position,\n      requiredPathname: requiredPathname,\n      scrollFunc: scrollFunc\n    }, hashes[i]));\n  }));\n};\nexports.ChildrenHash = ChildrenHash;\nexports.DEFAULT_SCROLL_BEHAVIOR = DEFAULT_SCROLL_BEHAVIOR;\nexports.DEFAULT_SCROLL_FUNC = DEFAULT_SCROLL_FUNC;\nexports.DEFAULT_SCROLL_POSITION = DEFAULT_SCROLL_POSITION;\nexports.HashScroll = HashScroll;\nexports.MultiHash = MultiHash;\nexports.useHashScroll = useHashScroll;","map":null,"metadata":{},"sourceType":"script"}